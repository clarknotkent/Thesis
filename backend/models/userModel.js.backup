const supabase = require('../db');
const bcrypt = require('bcrypt');

const userModel = {
  // Get all users with filtering and pagination
  getAllUsers: async (filters = {}, page = 1, limit = 10) => {
    try {
      let query = supabase
        .from('users')
        .select('user_id, username, email, role, first_name, last_name, status, created_at, last_login', { count: 'exact' })
        .eq('is_active', true);

      // Apply filters
      if (filters.search) {
        query = query.or(`username.ilike.%${filters.search}%,email.ilike.%${filters.search}%,first_name.ilike.%${filters.search}%,last_name.ilike.%${filters.search}%`);
      }

      if (filters.role) {
        query = query.eq('role', filters.role);
      }

      if (filters.status) {
        query = query.eq('status', filters.status);
      }

      // Apply pagination
      const offset = (page - 1) * limit;
      const { data, error, count } = await query
        .range(offset, offset + limit - 1)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return {
        users: data,
        totalCount: count,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(count / limit)
      };
    } catch (error) {
      console.error('Error fetching users:', error);
      throw error;
    }
  },

  // Get user by ID (without password)
  getUserById: async (id) => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('user_id, username, email, role, first_name, last_name, phone_number, status, created_at, last_login, profile_picture')
        .eq('user_id', id)
        .eq('is_active', true)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error fetching user by ID:', error);
      throw error;
    }
  },

  // Create new user
  createUser: async (userData) => {
    try {
      // Hash password
      const saltRounds = 12;
      const hashedPassword = await bcrypt.hash(userData.password, saltRounds);

      const { data, error } = await supabase
        .from('users')
        .insert({
          username: userData.username,
          email: userData.email,
          password_hash: hashedPassword,
          role: userData.role,
          first_name: userData.first_name,
          last_name: userData.last_name,
          phone_number: userData.phone_number,
          status: userData.status || 'active',
          is_active: true,
          created_at: new Date().toISOString()
        })
        .select('id, username, email, role, first_name, last_name, phone_number, status, created_at')
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  },

  // Update user
  updateUser: async (id, updates) => {
    try {
      const updateData = { ...updates };
      
      // Hash password if it's being updated
      if (updates.password) {
        const saltRounds = 12;
        updateData.password_hash = await bcrypt.hash(updates.password, saltRounds);
        delete updateData.password;
      }

      updateData.updated_at = new Date().toISOString();

      const { data, error } = await supabase
        .from('users')
        .update(updateData)
        .eq('id', id)
        .select('id, username, email, role, first_name, last_name, phone_number, status, updated_at')
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error updating user:', error);
      throw error;
    }
  },

  // Soft delete user
  deleteUser: async (id) => {
    try {
      const { data, error } = await supabase
        .from('users')
        .update({ 
          is_active: false,
          deleted_at: new Date().toISOString()
        })
        .eq('id', id)
        .select('id, username, email, status')
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error deleting user:', error);
      throw error;
    }
  },

  // Get user by username or email (for authentication)
  getUserByUsernameOrEmail: async (identifier) => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('id, username, email, password_hash, role, first_name, last_name, status')
        .or(`username.eq.${identifier},email.eq.${identifier}`)
        .eq('is_active', true)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error fetching user by username/email:', error);
      throw error;
    }
  },

  // Verify user password
  verifyPassword: async (plainPassword, hashedPassword) => {
    try {
      return await bcrypt.compare(plainPassword, hashedPassword);
    } catch (error) {
      console.error('Error verifying password:', error);
      throw error;
    }
  },

  // Update last login
  updateLastLogin: async (id) => {
    try {
      const { error } = await supabase
        .from('users')
        .update({ 
          last_login: new Date().toISOString()
        })
        .eq('id', id);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error('Error updating last login:', error);
      throw error;
    }
  },

  // Assign role to user
  assignRole: async (userId, role) => {
    try {
      const { data, error } = await supabase
        .from('users')
        .update({ 
          role: role,
          updated_at: new Date().toISOString()
        })
        .eq('id', userId)
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error assigning role:', error);
      throw error;
    }
  },

  // Get user profile with additional information
  getUserProfile: async (userId) => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select(`
          id,
          username,
          email,
          full_name,
          role,
          phone,
          facility_id,
          is_active,
          created_at,
          updated_at,
          last_login,
          facilities:facility_id (
            facility_name,
            facility_type,
            location
          )
        `)
        .eq('id', userId)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error fetching user profile:', error);
      throw error;
    }
  }
};

module.exports = userModel;